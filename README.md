# SE_Lab5
# گزارش
برای انجام این آزمایش از فریم ورک جنگو برای پیاده‌سازی دو سرویس موردنظر استفاده کردیم. در این آزمایش سامانه موردنظر دارای دو سرویس به نام‌های data و user می‌باشد. هدف کلی از این دو سرویس نیز آن است که با استفاده از سرویس user اطلاعات مربوط به کاربر مانند آدرس ایمیل و نام کاربری آن را دریافت کنیم و با استفاده از سرویس data اطلاعات مربوطه و داده‌هایی را در سامانه ذخیره کند. در این آزمایش قصد داریم که این دو سرویس را بر روی docker بالا آورده و عملکرد آن‌ها را نشان دهیم. شایان ذکر است که این دو سرویس در قالب دو API پیاده‌سازی شده‌اند که برای پیاده‌سازی آن‌ها از ModelViewset استفاده شده است. با این کار هر یک از عملیات CRUD را می‌توانیم بر روی این دو سرویس انجام دهیم. بنابراین در کل دو سرویس user و data خواهیم داشت که این دو سرویس در قالب دو ModelViewset پیاده‌سازی شده‌اند و به همین دلیل تمام عملیات CRUD بر روی آن‌ها امکان‌پذیر می‌باشد.

 در تصاویر زیر می‌توانید مدل، سریالایزر و ویوی مربوط به سرویس user را مشاهده کنید.
 
![image](https://github.com/alivanaki/SE_Lab5/assets/58647313/e94aab27-bf9b-424c-90cb-a1620904e655)
![image](https://github.com/alivanaki/SE_Lab5/assets/58647313/3049858f-c7a9-48b6-87c5-e47ee543302b)

 در تصاویر زیر می‌توانید مدل، سریالایزر و ویوی مربوط به سرویس data را مشاهده کنید.

 ![image](https://github.com/alivanaki/SE_Lab5/assets/58647313/e3647167-5cd1-4403-9dfd-1f74b0b5367d)
![image](https://github.com/alivanaki/SE_Lab5/assets/58647313/fe5709f4-d042-41ca-a872-a12b508ec520)

توجه داشته باشید که برای این بخش از آزمایش دو مدل ساده و دو سرویس ساده را در نظر گرفتیم.

در ادامه برای هر یک از سرویس‌ها موردنظر DockerFile مربوطه را تعریف می‌کنیم. در تصویر زیر می‌توانید محتویات DockerFileهای مربوطه را مشاهده کنید.

![image](https://github.com/alivanaki/SE_Lab5/assets/58647313/12155cc4-b0a9-42a6-aeaa-88731791e853)
![image](https://github.com/alivanaki/SE_Lab5/assets/58647313/ab3e3111-0b73-421a-9fb3-a3077c7e08d1)

هم‌چنین در ادامه فایل docker-compose.yml را به شکل زیر تعریف می‌کنیم.

![image](https://github.com/alivanaki/SE_Lab5/assets/58647313/3d1051ce-8755-40e2-80de-3708a8a08bd5)

در نهایت با استفاده از دستور `docker-compose up` سرویس‌های موردنظر را بر روی داکر بالا می‌آوریم.

![Docker_compose2](https://github.com/alivanaki/SE_Lab5/assets/58647313/73a3090b-4891-46e7-822f-b7967b81e865)

هم‌چنین با استفاده از دستورهای `docker ps` و `docker image ls` وجود imageها و containerها مربوط به سرویس‌های خود را بررسی می‌کنیم.

![Docker_compose3](https://github.com/alivanaki/SE_Lab5/assets/58647313/ad8a992e-8022-4dfa-9961-19480807f62a)

در پایان نیز درستی عملکرد APIهای خود را بررسی می‌کنیم. توجه داشته باشید که به ازای هر سرویس درستی دسترسی به API و پاسخ دریافتی از آن API به ازای هر url در تصاویر زیر بررسی شده است. در گام نخست درستی اجرای سرویس user را بررسی می‌کنیم.

![Untitled](https://github.com/alivanaki/SE_Lab5/assets/58647313/de68b664-6bbd-4495-81dd-6cc8dd185bda)
![Untitled2](https://github.com/alivanaki/SE_Lab5/assets/58647313/c02f0901-48ab-4c85-bddb-1703f46b9245)
![Untitled3](https://github.com/alivanaki/SE_Lab5/assets/58647313/e8c64368-d81b-417d-aea9-448053d87976)
![Untitled4](https://github.com/alivanaki/SE_Lab5/assets/58647313/82e4d23e-471e-4e3b-bf70-d5e9f5f41bb9)

حال درستی اجرای سرویس data را بررسی می‌کنیم.

![Untitled_1](https://github.com/alivanaki/SE_Lab5/assets/58647313/f4bce4b3-ca98-495b-8699-c5bc2aeba535)

![Untitled_2](https://github.com/alivanaki/SE_Lab5/assets/58647313/f0c999d7-0935-4ef0-a793-8a9b039843c5)

![Untitled_3](https://github.com/alivanaki/SE_Lab5/assets/58647313/1ed1eb8b-a5d2-4d4e-ac7a-334534b1658d)

![Untitled_4](https://github.com/alivanaki/SE_Lab5/assets/58647313/dfe52032-9fef-4177-b466-c9d18fd085a8)

توجه داشته باشید که با استفاده از دستور `docker-compose up --scale user-service=3 --scale data-service=3` عملیات Load Balancing را می‌توانیم انجام دهیم.

هم‌چنین نمودار استقرار معماری Microservice به شکل زیر می‌باشد:

![image](https://github.com/alivanaki/SE_Lab5/assets/58647313/0c3fd690-2570-4d64-afd6-d60d64b08a66)
# سوالات
۱. نمودار فوق از نوع component diagram است. در این نمودار بخش‌های مختلف سیستم شامل دو سرویسی که سیستم دارد نمایش داده شده‌اند. همچنین اجزای درون آن‌ها (دیتابیس، load balancer، سرویس و API) قابل مشاهده است.


۲. معماری MicroService می‌تواند در کنار DDD برود و به نوعی پیاده‌سازی از DDD باشد. در واقع آنچه DDD بیان می‌کند حل مساله بزرگ‌تر به صورت جداگانه در domain های مختلف خودش است. مثلا یک وب اپلیکیشن تاکسی اینترنتی را می‌توان به بخش‌هایی مانند مسیریابی، پرداخت، پیدا کردن ماشین و ... تقسیم کرد. طراحی و پیاده‌سازی هر کدام از این بخش‌ها تا حد زیادی از بقیه مستفل است که سبب پیاده‌سازی راحت‌تر DDD می‌شود. به هر کدام از این بخش‌ها Bounded Context (BC) گفته می‌شود. حال در ترکیب با معماری میکروسرویس همین BCها به عنوان microservice های ما عمل می‌کنند و مستقل از بقیه اجرا می‌شوند. در واقع ملاک جداسازی طراحی در DDD می‌تواند به عنوان ملاکی برای microservice بکار برود. همین‌طور آنچه در DDD به عنوان context map می‌شناسیم، می‌تواند برای فهمیدن نحوه ارتباط سرویس‌ها در microservice بکار برود.
منبع:
https://semaphoreci.com/blog/domain-driven-design-microservices


۳. داکر کامپوز را می‌توان ابزاری برای تعریف و اجرای برنامه‌هایی با چندین کانتینر تعریف کرد. ورودی آن یک فایل YAML است که طبق آن تعداد و نوع کانتینرها، نحوه ارتباط شبکه و پردازنده و حافظه و ... مشخص می‌شود. با داشتن این فایل با یک دستور می‌توان مجموعه پیچیده‌ای از سرویس‌ها را به شکل دلخواه اجرا کرد.
به طور کلی می‌توان داکر کامپوز را نوعی ابزار orchestration در نظر گرفت. بدین معنی که نحوه اجرای یک برنامه با چندین کانتینر را کنترل می‌کند. اما به طور معمول برای برنامه‌هایی با سایز بزرگ‌تر معمولا از ابزارهایی مایی kubernetes استفاده می‌شود. در واقع امکاناتی که در داکر کامپوز وجود دارد تا حدی محدود است و استفاده از ابزارهای مخصوص orchestration معمولا نیاز است.
https://docs.docker.com/compose/

